<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

<script type="text/javascript">
// 数值型
    var a = 100;
    b = a;
    console.log(b);
// 引用型
    var a={age:200};
    var b=a;
    b.age=21;
    console.log (a.age);
// typeof运算符
// 构造函数
function Foo(name ,age){
    this.name=name;
    this.age=age;
    this.class ="class-1"
    // return this 默认有这行
}
var f= new Foo("zhangsan" ,28);
    // new 在执行后里面的函数会先变成一个空对象，在构造函数中return把this返回为空。
//构造函数扩展
var a={} ;
    // 是var a=new Object（）的语法糖
var a=[]
    // 是var a=new Array()的语法糖
function Fool(){}
    // 是var Foo=new Function(){}的语法糖
// 推荐使用前面的写法
// instanceof用来判断一个函数是不是构造函数
//_proto_属性，属性值是一个普通的对象
var Foo ={};
Foo.name="zhangsan";
var Foo1 =[];
Foo1.name="lisi";
function Foo2(){};
Foo2.name="yangyang";
console.log(Foo.__proto__);
console.log(Foo1.__proto__);
console.log(Foo2.__proto__);
console.log(Foo.prototype);
console.log(Foo1.prototype);
console.log(Foo2.prototype);
console.log(Foo.__proto__===Object.prototype);
// 当在对象中找不到某个属性的时候，就从它的隐式原型去找也就是去它的构造函数的显示原型中找。
function a(name,age){
    this.name=name;
}
a.prototype.alertName= function(){
    alert(this.name)
}
var f= new a("shang",28)
f.printName= function(){
    console.log(this.name)
}
f.printName;
f.alertName;
</script>
</body>
</html>